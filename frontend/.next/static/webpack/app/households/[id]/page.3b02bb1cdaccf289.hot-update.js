"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/households/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/mock-api-data.ts":
/*!**********************************!*\
  !*** ./src/lib/mock-api-data.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMockActivity: function() { return /* binding */ getMockActivity; },\n/* harmony export */   getMockAllocation: function() { return /* binding */ getMockAllocation; },\n/* harmony export */   getMockCash: function() { return /* binding */ getMockCash; },\n/* harmony export */   getMockOverview: function() { return /* binding */ getMockOverview; },\n/* harmony export */   getMockPerformance: function() { return /* binding */ getMockPerformance; },\n/* harmony export */   getMockPlanning: function() { return /* binding */ getMockPlanning; },\n/* harmony export */   getMockPositions: function() { return /* binding */ getMockPositions; },\n/* harmony export */   getMockReports: function() { return /* binding */ getMockReports; }\n/* harmony export */ });\n/* harmony import */ var _mock_households__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mock-households */ \"(app-pages-browser)/./src/lib/mock-households.ts\");\n\nfunction getMockOverview(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    return {\n        household: {\n            id: household.id,\n            name: household.name,\n            primaryAdvisor: household.advisorName,\n            riskProfile: household.riskProfile === \"Ultra-Conservative\" ? \"Conservative\" : household.riskProfile,\n            lastSync: new Date().toISOString()\n        },\n        totalAssets: household.totalAssets,\n        ytdReturn: household.ytdPerformance,\n        benchmarkReturn: household.ytdPerformance * 0.9,\n        accountsCount: household.accountsCount,\n        totalCash: household.totalCash,\n        avgCashYield: 2.5,\n        executiveSummary: [\n            \"Portfolio performance of \".concat(household.ytdPerformance, \"% YTD\"),\n            \"Total assets under management: $\".concat((household.totalAssets / 1000000).toFixed(1), \"M\"),\n            \"Risk profile aligned with \".concat(household.riskProfile.toLowerCase(), \" strategy\")\n        ],\n        lastUpdated: new Date().toISOString()\n    };\n}\nfunction getMockPerformance(householdId, range) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    const validRanges = [\n        \"3M\",\n        \"6M\",\n        \"1Y\",\n        \"3Y\",\n        \"5Y\"\n    ];\n    const validRange = validRanges.includes(range) ? range : \"6M\";\n    // Generate performance data based on the selected range\n    const rangeConfig = {\n        \"3M\": {\n            days: 90,\n            points: 30\n        },\n        \"6M\": {\n            days: 180,\n            points: 60\n        },\n        \"1Y\": {\n            days: 365,\n            points: 120\n        },\n        \"3Y\": {\n            days: 365 * 3,\n            points: 150\n        },\n        \"5Y\": {\n            days: 365 * 5,\n            points: 200\n        }\n    };\n    const config = rangeConfig[validRange];\n    const data = [];\n    // Create more distinct patterns for each range\n    const baseValue = household.totalAssets;\n    const baseReturn = household.ytdPerformance / 100;\n    for(let i = 0; i < config.points; i++){\n        const date = new Date();\n        date.setDate(date.getDate() - (config.days - i * config.days / config.points));\n        const progress = i / config.points;\n        // Different performance patterns for different ranges\n        let performanceMultiplier;\n        let volatilityFactor;\n        switch(validRange){\n            case \"3M\":\n                performanceMultiplier = 0.2; // 20% of YTD performance\n                volatilityFactor = 0.02; // Lower volatility for short term\n                break;\n            case \"6M\":\n                performanceMultiplier = 0.5; // 50% of YTD performance\n                volatilityFactor = 0.03;\n                break;\n            case \"1Y\":\n                performanceMultiplier = 1.0; // Full YTD performance\n                volatilityFactor = 0.04;\n                break;\n            case \"3Y\":\n                performanceMultiplier = 2.5; // Annualized over 3 years\n                volatilityFactor = 0.06;\n                break;\n            case \"5Y\":\n                performanceMultiplier = 4.0; // Annualized over 5 years\n                volatilityFactor = 0.08;\n                break;\n        }\n        // Add consistent but noticeable volatility\n        const seed = (householdId.charCodeAt(0) + i * 7 + validRange.charCodeAt(0)) % 100;\n        const volatility = Math.sin((seed + i) * 0.1) * volatilityFactor;\n        // Create trending performance with volatility\n        const trendReturn = baseReturn * performanceMultiplier * progress;\n        const finalValue = baseValue * (1 + trendReturn + volatility);\n        const benchmarkValue = baseValue * (1 + trendReturn * 0.85 + volatility * 0.3);\n        data.push({\n            date: date.toISOString().split(\"T\")[0],\n            value: Math.round(finalValue),\n            benchmark: Math.round(benchmarkValue)\n        });\n    }\n    return {\n        data,\n        range: validRange,\n        totalReturn: household.ytdPerformance * (validRange === \"3M\" ? 0.25 : validRange === \"6M\" ? 0.5 : 1),\n        benchmarkReturn: household.ytdPerformance * 0.8 * (validRange === \"3M\" ? 0.25 : validRange === \"6M\" ? 0.5 : 1),\n        volatility: 12.5,\n        sharpeRatio: 1.2\n    };\n}\nfunction getMockAllocation(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    return {\n        allocation: [\n            {\n                name: \"US Equity\",\n                value: 50,\n                percentage: 50,\n                color: \"#0f766e\"\n            },\n            {\n                name: \"International Equity\",\n                value: 20,\n                percentage: 20,\n                color: \"#3b82f6\"\n            },\n            {\n                name: \"Fixed Income\",\n                value: 25,\n                percentage: 25,\n                color: \"#10b981\"\n            },\n            {\n                name: \"Alternatives\",\n                value: 5,\n                percentage: 5,\n                color: \"#f59e0b\"\n            }\n        ],\n        policyDrift: 2.3,\n        rebalanceNeeded: false,\n        lastRebalance: \"2025-08-15T00:00:00Z\"\n    };\n}\nfunction getMockActivity(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    return {\n        activities: [\n            {\n                id: \"\".concat(householdId, \"-1\"),\n                type: \"meeting\",\n                priority: \"high\",\n                status: \"completed\",\n                date: new Date().toISOString(),\n                title: \"Quarterly Review - \".concat(household.name),\n                description: \"Portfolio review and planning discussion for \".concat(household.name),\n                tags: [\n                    \"review\",\n                    \"quarterly\",\n                    household.riskProfile.toLowerCase()\n                ],\n                author: household.advisorName\n            },\n            {\n                id: \"\".concat(householdId, \"-2\"),\n                type: \"trade\",\n                priority: \"medium\",\n                status: \"completed\",\n                date: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),\n                title: \"Portfolio Rebalancing - \".concat(household.name),\n                description: \"Executed rebalancing trades to maintain target allocation\",\n                tags: [\n                    \"rebalancing\",\n                    \"trade\"\n                ],\n                author: household.advisorName\n            }\n        ],\n        totalCount: 2,\n        hasMore: false\n    };\n}\nfunction generateCashTrendData(householdId, range, totalCash) {\n    const validRanges = [\n        \"3M\",\n        \"6M\",\n        \"1Y\"\n    ];\n    const validRange = validRanges.includes(range) ? range : \"6M\";\n    const rangeConfig = {\n        \"3M\": {\n            days: 90,\n            points: 20\n        },\n        \"6M\": {\n            days: 180,\n            points: 30\n        },\n        \"1Y\": {\n            days: 365,\n            points: 50\n        }\n    };\n    const config = rangeConfig[validRange];\n    const data = [];\n    for(let i = 0; i < config.points; i++){\n        const date = new Date();\n        date.setDate(date.getDate() - (config.days - i * config.days / config.points));\n        // Generate gradual trend with some variation\n        const progress = i / config.points;\n        const seed = (householdId.charCodeAt(0) + i) % 100;\n        const variation = (seed - 50) / 500; // Small variations\n        const balance = totalCash * (0.9 + 0.1 * progress + variation);\n        data.push({\n            date: date.toISOString().split(\"T\")[0],\n            balance: Math.max(0, balance),\n            checking: Math.max(0, balance * 0.4),\n            savings: Math.max(0, balance * 0.6),\n            cd: 0\n        });\n    }\n    return data;\n}\nfunction getMockCash(householdId) {\n    let range = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"6M\";\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    const checkingBalance = household.totalCash * 0.4;\n    const savingsBalance = household.totalCash * 0.6;\n    return {\n        accounts: [\n            {\n                id: \"\".concat(householdId, \"-checking\"),\n                name: \"\".concat(household.name, \" Checking\"),\n                type: \"checking\",\n                balance: checkingBalance,\n                apy: 0.1,\n                isActive: true,\n                institution: \"Chase Bank\"\n            },\n            {\n                id: \"\".concat(householdId, \"-savings\"),\n                name: \"\".concat(household.name, \" High Yield Savings\"),\n                type: \"savings\",\n                balance: savingsBalance,\n                apy: 4.5,\n                isActive: true,\n                institution: \"Marcus by Goldman Sachs\"\n            }\n        ],\n        totalBalance: household.totalCash,\n        avgYield: 2.8,\n        trendData: generateCashTrendData(householdId, range, household.totalCash),\n        alerts: []\n    };\n}\nfunction getMockPlanning(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    const isRetirementAge = household.name.includes(\"Retirement\") || household.riskProfile === \"Conservative\";\n    return {\n        rmds: isRetirementAge ? [\n            {\n                id: \"\".concat(householdId, \"-rmd-1\"),\n                accountName: \"Traditional IRA\",\n                owner: household.primaryContact,\n                dueDate: \"2025-12-31T23:59:59Z\",\n                requiredAmount: household.totalAssets * 0.04,\n                completedAmount: 0,\n                status: \"pending\"\n            }\n        ] : [],\n        beneficiaries: [\n            {\n                id: \"\".concat(householdId, \"-ben-1\"),\n                accountName: \"Primary Investment Account\",\n                accountType: \"Investment\",\n                hasPrimary: true,\n                hasContingent: true,\n                lastReviewed: \"2025-01-15T00:00:00Z\",\n                status: \"complete\"\n            }\n        ],\n        nextInteraction: {\n            date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n            type: \"review\",\n            description: \"Quarterly portfolio review and planning discussion\"\n        },\n        custodialTransitions: []\n    };\n}\nfunction getMockPositions(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    const investedAssets = household.totalAssets - household.totalCash;\n    const positions = [\n        {\n            id: \"\".concat(householdId, \"-pos-1\"),\n            symbol: \"AAPL\",\n            name: \"Apple Inc.\",\n            assetClass: \"Equity\",\n            quantity: Math.floor(investedAssets * 0.15 / 175),\n            marketValue: investedAssets * 0.15,\n            costBasis: investedAssets * 0.15 * 0.9,\n            weight: 15.0,\n            lastPrice: 175.25,\n            sector: \"Technology\"\n        },\n        {\n            id: \"\".concat(householdId, \"-pos-2\"),\n            symbol: \"VTI\",\n            name: \"Vanguard Total Stock Market ETF\",\n            assetClass: \"Equity\",\n            quantity: Math.floor(investedAssets * 0.35 / 240),\n            marketValue: investedAssets * 0.35,\n            costBasis: investedAssets * 0.35 * 0.95,\n            weight: 35.0,\n            lastPrice: 240.15\n        },\n        {\n            id: \"\".concat(householdId, \"-pos-3\"),\n            symbol: \"BND\",\n            name: \"Vanguard Total Bond Market ETF\",\n            assetClass: \"Fixed Income\",\n            quantity: Math.floor(investedAssets * 0.25 / 78),\n            marketValue: investedAssets * 0.25,\n            costBasis: investedAssets * 0.25 * 1.02,\n            weight: 25.0,\n            lastPrice: 78.45\n        }\n    ];\n    const totalMarketValue = positions.reduce((sum, pos)=>sum + pos.marketValue, 0);\n    const totalCostBasis = positions.reduce((sum, pos)=>sum + pos.costBasis, 0);\n    const totalGainLoss = totalMarketValue - totalCostBasis;\n    return {\n        positions,\n        summary: {\n            totalMarketValue,\n            totalCostBasis,\n            totalGainLoss,\n            totalGainLossPercent: totalGainLoss / totalCostBasis * 100,\n            positionsCount: positions.length\n        }\n    };\n}\nfunction getMockReports(householdId) {\n    const household = (0,_mock_households__WEBPACK_IMPORTED_MODULE_0__.getHouseholdById)(householdId);\n    if (!household) throw new Error(\"Household not found\");\n    return {\n        statements: [\n            {\n                id: \"\".concat(householdId, \"-stmt-monthly\"),\n                name: \"Monthly Statement - \".concat(household.name),\n                type: \"monthly\",\n                date: \"2025-09-01T00:00:00Z\",\n                size: \"2.3 MB\",\n                url: \"/statements/\".concat(householdId, \"/monthly-2025-09.pdf\")\n            },\n            {\n                id: \"\".concat(householdId, \"-stmt-quarterly\"),\n                name: \"Quarterly Performance Report - \".concat(household.name),\n                type: \"quarterly\",\n                date: \"2025-07-01T00:00:00Z\",\n                size: \"1.8 MB\",\n                url: \"/statements/\".concat(householdId, \"/quarterly-2025-q3.pdf\")\n            }\n        ],\n        analytics: [\n            {\n                id: \"\".concat(householdId, \"-analytics-performance\"),\n                name: \"Portfolio Performance Analysis\",\n                description: \"Comprehensive performance analysis for \".concat(household.name, \" including risk metrics and attribution\"),\n                generatedDate: \"2025-09-24T00:00:00Z\",\n                url: \"/analytics/\".concat(householdId, \"/performance-analysis.pdf\")\n            },\n            {\n                id: \"\".concat(householdId, \"-analytics-allocation\"),\n                name: \"Asset Allocation Review\",\n                description: \"Current vs target allocation with rebalancing recommendations\",\n                generatedDate: \"2025-09-20T00:00:00Z\",\n                url: \"/analytics/\".concat(householdId, \"/allocation-review.pdf\")\n            }\n        ]\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbW9jay1hcGktZGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUQ7QUFZOUMsU0FBU0MsZ0JBQWdCQyxXQUFtQjtJQUNqRCxNQUFNQyxZQUFZSCxrRUFBZ0JBLENBQUNFO0lBQ25DLElBQUksQ0FBQ0MsV0FBVyxNQUFNLElBQUlDLE1BQU07SUFFaEMsT0FBTztRQUNMRCxXQUFXO1lBQ1RFLElBQUlGLFVBQVVFLEVBQUU7WUFDaEJDLE1BQU1ILFVBQVVHLElBQUk7WUFDcEJDLGdCQUFnQkosVUFBVUssV0FBVztZQUNyQ0MsYUFBYU4sVUFBVU0sV0FBVyxLQUFLLHVCQUF1QixpQkFBaUJOLFVBQVVNLFdBQVc7WUFDcEdDLFVBQVUsSUFBSUMsT0FBT0MsV0FBVztRQUNsQztRQUNBQyxhQUFhVixVQUFVVSxXQUFXO1FBQ2xDQyxXQUFXWCxVQUFVWSxjQUFjO1FBQ25DQyxpQkFBaUJiLFVBQVVZLGNBQWMsR0FBRztRQUM1Q0UsZUFBZWQsVUFBVWMsYUFBYTtRQUN0Q0MsV0FBV2YsVUFBVWUsU0FBUztRQUM5QkMsY0FBYztRQUNkQyxrQkFBa0I7WUFDZiw0QkFBb0QsT0FBekJqQixVQUFVWSxjQUFjLEVBQUM7WUFDcEQsbUNBQStFLE9BQTdDLENBQUNaLFVBQVVVLFdBQVcsR0FBRyxPQUFNLEVBQUdRLE9BQU8sQ0FBQyxJQUFHO1lBQy9FLDZCQUFnRSxPQUFwQ2xCLFVBQVVNLFdBQVcsQ0FBQ2EsV0FBVyxJQUFHO1NBQ2xFO1FBQ0RDLGFBQWEsSUFBSVosT0FBT0MsV0FBVztJQUNyQztBQUNGO0FBRU8sU0FBU1ksbUJBQW1CdEIsV0FBbUIsRUFBRXVCLEtBQWE7SUFDbkUsTUFBTXRCLFlBQVlILGtFQUFnQkEsQ0FBQ0U7SUFDbkMsSUFBSSxDQUFDQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtJQUVoQyxNQUFNc0IsY0FBYztRQUFDO1FBQU07UUFBTTtRQUFNO1FBQU07S0FBSztJQUNsRCxNQUFNQyxhQUFh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a0NBQWlELE9BQWZILFVBQVVHLElBQUk7Z0JBQ3RENkQsTUFBTTtnQkFDTjlCLE1BQU07Z0JBQ05rRyxNQUFNO2dCQUNOQyxLQUFLLGVBQTJCLE9BQVp0SSxhQUFZO1lBQ2xDO1NBQ0Q7UUFDRHVJLFdBQVc7WUFDVDtnQkFDRXBJLElBQUksR0FBZSxPQUFaSCxhQUFZO2dCQUNuQkksTUFBTTtnQkFDTmlFLGFBQWEsMENBQXlELE9BQWZwRSxVQUFVRyxJQUFJLEVBQUM7Z0JBQ3RFb0ksZUFBZTtnQkFDZkYsS0FBSyxjQUEwQixPQUFadEksYUFBWTtZQUNqQztZQUNBO2dCQUNFRyxJQUFJLEdBQWUsT0FBWkgsYUFBWTtnQkFDbkJJLE1BQU07Z0JBQ05pRSxhQUFhO2dCQUNibUUsZUFBZTtnQkFDZkYsS0FBSyxjQUEwQixPQUFadEksYUFBWTtZQUNqQztTQUNEO0lBQ0g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL21vY2stYXBpLWRhdGEudHM/YjE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRIb3VzZWhvbGRCeUlkIH0gZnJvbSAnLi9tb2NrLWhvdXNlaG9sZHMnO1xyXG5pbXBvcnQgdHlwZSB7IFxyXG4gIE92ZXJ2aWV3UmVzcG9uc2UsIFxyXG4gIFBlcmZvcm1hbmNlUmVzcG9uc2UsIFxyXG4gIEFsbG9jYXRpb25SZXNwb25zZSwgXHJcbiAgQWN0aXZpdHlSZXNwb25zZSwgXHJcbiAgQ2FzaFJlc3BvbnNlLFxyXG4gIFBsYW5uaW5nUmVzcG9uc2UsXHJcbiAgUG9zaXRpb25zUmVzcG9uc2UsXHJcbiAgUmVwb3J0c1Jlc3BvbnNlXHJcbn0gZnJvbSAnLi9zY2hlbWFzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2NrT3ZlcnZpZXcoaG91c2Vob2xkSWQ6IHN0cmluZyk6IE92ZXJ2aWV3UmVzcG9uc2Uge1xyXG4gIGNvbnN0IGhvdXNlaG9sZCA9IGdldEhvdXNlaG9sZEJ5SWQoaG91c2Vob2xkSWQpO1xyXG4gIGlmICghaG91c2Vob2xkKSB0aHJvdyBuZXcgRXJyb3IoJ0hvdXNlaG9sZCBub3QgZm91bmQnKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhvdXNlaG9sZDoge1xyXG4gICAgICBpZDogaG91c2Vob2xkLmlkLFxyXG4gICAgICBuYW1lOiBob3VzZWhvbGQubmFtZSxcclxuICAgICAgcHJpbWFyeUFkdmlzb3I6IGhvdXNlaG9sZC5hZHZpc29yTmFtZSxcclxuICAgICAgcmlza1Byb2ZpbGU6IGhvdXNlaG9sZC5yaXNrUHJvZmlsZSA9PT0gJ1VsdHJhLUNvbnNlcnZhdGl2ZScgPyAnQ29uc2VydmF0aXZlJyA6IGhvdXNlaG9sZC5yaXNrUHJvZmlsZSBhcyBhbnksXHJcbiAgICAgIGxhc3RTeW5jOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9LFxyXG4gICAgdG90YWxBc3NldHM6IGhvdXNlaG9sZC50b3RhbEFzc2V0cyxcclxuICAgIHl0ZFJldHVybjogaG91c2Vob2xkLnl0ZFBlcmZvcm1hbmNlLFxyXG4gICAgYmVuY2htYXJrUmV0dXJuOiBob3VzZWhvbGQueXRkUGVyZm9ybWFuY2UgKiAwLjksXHJcbiAgICBhY2NvdW50c0NvdW50OiBob3VzZWhvbGQuYWNjb3VudHNDb3VudCxcclxuICAgIHRvdGFsQ2FzaDogaG91c2Vob2xkLnRvdGFsQ2FzaCxcclxuICAgIGF2Z0Nhc2hZaWVsZDogMi41LFxyXG4gICAgZXhlY3V0aXZlU3VtbWFyeTogW1xyXG4gICAgICBgUG9ydGZvbGlvIHBlcmZvcm1hbmNlIG9mICR7aG91c2Vob2xkLnl0ZFBlcmZvcm1hbmNlfSUgWVREYCxcclxuICAgICAgYFRvdGFsIGFzc2V0cyB1bmRlciBtYW5hZ2VtZW50OiAkJHsoaG91c2Vob2xkLnRvdGFsQXNzZXRzIC8gMTAwMDAwMCkudG9GaXhlZCgxKX1NYCxcclxuICAgICAgYFJpc2sgcHJvZmlsZSBhbGlnbmVkIHdpdGggJHtob3VzZWhvbGQucmlza1Byb2ZpbGUudG9Mb3dlckNhc2UoKX0gc3RyYXRlZ3lgXHJcbiAgICBdLFxyXG4gICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9ja1BlcmZvcm1hbmNlKGhvdXNlaG9sZElkOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiBQZXJmb3JtYW5jZVJlc3BvbnNlIHtcclxuICBjb25zdCBob3VzZWhvbGQgPSBnZXRIb3VzZWhvbGRCeUlkKGhvdXNlaG9sZElkKTtcclxuICBpZiAoIWhvdXNlaG9sZCkgdGhyb3cgbmV3IEVycm9yKCdIb3VzZWhvbGQgbm90IGZvdW5kJyk7XHJcblxyXG4gIGNvbnN0IHZhbGlkUmFuZ2VzID0gWyczTScsICc2TScsICcxWScsICczWScsICc1WSddIGFzIGNvbnN0O1xyXG4gIGNvbnN0IHZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlcy5pbmNsdWRlcyhyYW5nZSBhcyBhbnkpID8gcmFuZ2UgYXMgYW55IDogJzZNJztcclxuXHJcbiAgLy8gR2VuZXJhdGUgcGVyZm9ybWFuY2UgZGF0YSBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgcmFuZ2VcclxuICBjb25zdCByYW5nZUNvbmZpZzogUmVjb3JkPHR5cGVvZiB2YWxpZFJhbmdlLCB7IGRheXM6IG51bWJlcjsgcG9pbnRzOiBudW1iZXIgfT4gPSB7XHJcbiAgICAnM00nOiB7IGRheXM6IDkwLCBwb2ludHM6IDMwIH0sXHJcbiAgICAnNk0nOiB7IGRheXM6IDE4MCwgcG9pbnRzOiA2MCB9LFxyXG4gICAgJzFZJzogeyBkYXlzOiAzNjUsIHBvaW50czogMTIwIH0sXHJcbiAgICAnM1knOiB7IGRheXM6IDM2NSAqIDMsIHBvaW50czogMTUwIH0sXHJcbiAgICAnNVknOiB7IGRheXM6IDM2NSAqIDUsIHBvaW50czogMjAwIH0sXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY29uZmlnID0gcmFuZ2VDb25maWdbdmFsaWRSYW5nZV07XHJcbiAgY29uc3QgZGF0YSA9IFtdO1xyXG4gIFxyXG4gIC8vIENyZWF0ZSBtb3JlIGRpc3RpbmN0IHBhdHRlcm5zIGZvciBlYWNoIHJhbmdlXHJcbiAgY29uc3QgYmFzZVZhbHVlID0gaG91c2Vob2xkLnRvdGFsQXNzZXRzO1xyXG4gIGNvbnN0IGJhc2VSZXR1cm4gPSBob3VzZWhvbGQueXRkUGVyZm9ybWFuY2UgLyAxMDA7XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcucG9pbnRzOyBpKyspIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGNvbmZpZy5kYXlzIC0gKGkgKiBjb25maWcuZGF5cyAvIGNvbmZpZy5wb2ludHMpKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHByb2dyZXNzID0gaSAvIGNvbmZpZy5wb2ludHM7XHJcbiAgICBcclxuICAgIC8vIERpZmZlcmVudCBwZXJmb3JtYW5jZSBwYXR0ZXJucyBmb3IgZGlmZmVyZW50IHJhbmdlc1xyXG4gICAgbGV0IHBlcmZvcm1hbmNlTXVsdGlwbGllcjogbnVtYmVyO1xyXG4gICAgbGV0IHZvbGF0aWxpdHlGYWN0b3I6IG51bWJlcjtcclxuICAgIFxyXG4gICAgc3dpdGNoICh2YWxpZFJhbmdlKSB7XHJcbiAgICAgIGNhc2UgJzNNJzpcclxuICAgICAgICBwZXJmb3JtYW5jZU11bHRpcGxpZXIgPSAwLjI7IC8vIDIwJSBvZiBZVEQgcGVyZm9ybWFuY2VcclxuICAgICAgICB2b2xhdGlsaXR5RmFjdG9yID0gMC4wMjsgLy8gTG93ZXIgdm9sYXRpbGl0eSBmb3Igc2hvcnQgdGVybVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICc2TSc6XHJcbiAgICAgICAgcGVyZm9ybWFuY2VNdWx0aXBsaWVyID0gMC41OyAvLyA1MCUgb2YgWVREIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgdm9sYXRpbGl0eUZhY3RvciA9IDAuMDM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJzFZJzpcclxuICAgICAgICBwZXJmb3JtYW5jZU11bHRpcGxpZXIgPSAxLjA7IC8vIEZ1bGwgWVREIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgdm9sYXRpbGl0eUZhY3RvciA9IDAuMDQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJzNZJzpcclxuICAgICAgICBwZXJmb3JtYW5jZU11bHRpcGxpZXIgPSAyLjU7IC8vIEFubnVhbGl6ZWQgb3ZlciAzIHllYXJzXHJcbiAgICAgICAgdm9sYXRpbGl0eUZhY3RvciA9IDAuMDY7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJzVZJzpcclxuICAgICAgICBwZXJmb3JtYW5jZU11bHRpcGxpZXIgPSA0LjA7IC8vIEFubnVhbGl6ZWQgb3ZlciA1IHllYXJzXHJcbiAgICAgICAgdm9sYXRpbGl0eUZhY3RvciA9IDAuMDg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFkZCBjb25zaXN0ZW50IGJ1dCBub3RpY2VhYmxlIHZvbGF0aWxpdHlcclxuICAgIGNvbnN0IHNlZWQgPSAoaG91c2Vob2xkSWQuY2hhckNvZGVBdCgwKSArIGkgKiA3ICsgdmFsaWRSYW5nZS5jaGFyQ29kZUF0KDApKSAlIDEwMDtcclxuICAgIGNvbnN0IHZvbGF0aWxpdHkgPSBNYXRoLnNpbigoc2VlZCArIGkpICogMC4xKSAqIHZvbGF0aWxpdHlGYWN0b3I7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSB0cmVuZGluZyBwZXJmb3JtYW5jZSB3aXRoIHZvbGF0aWxpdHlcclxuICAgIGNvbnN0IHRyZW5kUmV0dXJuID0gYmFzZVJldHVybiAqIHBlcmZvcm1hbmNlTXVsdGlwbGllciAqIHByb2dyZXNzO1xyXG4gICAgY29uc3QgZmluYWxWYWx1ZSA9IGJhc2VWYWx1ZSAqICgxICsgdHJlbmRSZXR1cm4gKyB2b2xhdGlsaXR5KTtcclxuICAgIGNvbnN0IGJlbmNobWFya1ZhbHVlID0gYmFzZVZhbHVlICogKDEgKyB0cmVuZFJldHVybiAqIDAuODUgKyB2b2xhdGlsaXR5ICogMC4zKTtcclxuICAgIFxyXG4gICAgZGF0YS5wdXNoKHtcclxuICAgICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgIHZhbHVlOiBNYXRoLnJvdW5kKGZpbmFsVmFsdWUpLFxyXG4gICAgICBiZW5jaG1hcms6IE1hdGgucm91bmQoYmVuY2htYXJrVmFsdWUpLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZGF0YSxcclxuICAgIHJhbmdlOiB2YWxpZFJhbmdlLFxyXG4gICAgdG90YWxSZXR1cm46IGhvdXNlaG9sZC55dGRQZXJmb3JtYW5jZSAqICh2YWxpZFJhbmdlID09PSAnM00nID8gMC4yNSA6IHZhbGlkUmFuZ2UgPT09ICc2TScgPyAwLjUgOiAxKSxcclxuICAgIGJlbmNobWFya1JldHVybjogaG91c2Vob2xkLnl0ZFBlcmZvcm1hbmNlICogMC44ICogKHZhbGlkUmFuZ2UgPT09ICczTScgPyAwLjI1IDogdmFsaWRSYW5nZSA9PT0gJzZNJyA/IDAuNSA6IDEpLFxyXG4gICAgdm9sYXRpbGl0eTogMTIuNSxcclxuICAgIHNoYXJwZVJhdGlvOiAxLjIsXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vY2tBbGxvY2F0aW9uKGhvdXNlaG9sZElkOiBzdHJpbmcpOiBBbGxvY2F0aW9uUmVzcG9uc2Uge1xyXG4gIGNvbnN0IGhvdXNlaG9sZCA9IGdldEhvdXNlaG9sZEJ5SWQoaG91c2Vob2xkSWQpO1xyXG4gIGlmICghaG91c2Vob2xkKSB0aHJvdyBuZXcgRXJyb3IoJ0hvdXNlaG9sZCBub3QgZm91bmQnKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGFsbG9jYXRpb246IFtcclxuICAgICAgeyBuYW1lOiAnVVMgRXF1aXR5JywgdmFsdWU6IDUwLCBwZXJjZW50YWdlOiA1MCwgY29sb3I6ICcjMGY3NjZlJyB9LFxyXG4gICAgICB7IG5hbWU6ICdJbnRlcm5hdGlvbmFsIEVxdWl0eScsIHZhbHVlOiAyMCwgcGVyY2VudGFnZTogMjAsIGNvbG9yOiAnIzNiODJmNicgfSxcclxuICAgICAgeyBuYW1lOiAnRml4ZWQgSW5jb21lJywgdmFsdWU6IDI1LCBwZXJjZW50YWdlOiAyNSwgY29sb3I6ICcjMTBiOTgxJyB9LFxyXG4gICAgICB7IG5hbWU6ICdBbHRlcm5hdGl2ZXMnLCB2YWx1ZTogNSwgcGVyY2VudGFnZTogNSwgY29sb3I6ICcjZjU5ZTBiJyB9LFxyXG4gICAgXSxcclxuICAgIHBvbGljeURyaWZ0OiAyLjMsXHJcbiAgICByZWJhbGFuY2VOZWVkZWQ6IGZhbHNlLFxyXG4gICAgbGFzdFJlYmFsYW5jZTogJzIwMjUtMDgtMTVUMDA6MDA6MDBaJyxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9ja0FjdGl2aXR5KGhvdXNlaG9sZElkOiBzdHJpbmcpOiBBY3Rpdml0eVJlc3BvbnNlIHtcclxuICBjb25zdCBob3VzZWhvbGQgPSBnZXRIb3VzZWhvbGRCeUlkKGhvdXNlaG9sZElkKTtcclxuICBpZiAoIWhvdXNlaG9sZCkgdGhyb3cgbmV3IEVycm9yKCdIb3VzZWhvbGQgbm90IGZvdW5kJyk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhY3Rpdml0aWVzOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogYCR7aG91c2Vob2xkSWR9LTFgLFxyXG4gICAgICAgIHR5cGU6ICdtZWV0aW5nJyBhcyBjb25zdCxcclxuICAgICAgICBwcmlvcml0eTogJ2hpZ2gnIGFzIGNvbnN0LFxyXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcgYXMgY29uc3QsXHJcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHRpdGxlOiBgUXVhcnRlcmx5IFJldmlldyAtICR7aG91c2Vob2xkLm5hbWV9YCxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYFBvcnRmb2xpbyByZXZpZXcgYW5kIHBsYW5uaW5nIGRpc2N1c3Npb24gZm9yICR7aG91c2Vob2xkLm5hbWV9YCxcclxuICAgICAgICB0YWdzOiBbJ3JldmlldycsICdxdWFydGVybHknLCBob3VzZWhvbGQucmlza1Byb2ZpbGUudG9Mb3dlckNhc2UoKV0sXHJcbiAgICAgICAgYXV0aG9yOiBob3VzZWhvbGQuYWR2aXNvck5hbWUsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogYCR7aG91c2Vob2xkSWR9LTJgLFxyXG4gICAgICAgIHR5cGU6ICd0cmFkZScgYXMgY29uc3QsXHJcbiAgICAgICAgcHJpb3JpdHk6ICdtZWRpdW0nIGFzIGNvbnN0LFxyXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcgYXMgY29uc3QsXHJcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgdGl0bGU6IGBQb3J0Zm9saW8gUmViYWxhbmNpbmcgLSAke2hvdXNlaG9sZC5uYW1lfWAsXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdFeGVjdXRlZCByZWJhbGFuY2luZyB0cmFkZXMgdG8gbWFpbnRhaW4gdGFyZ2V0IGFsbG9jYXRpb24nLFxyXG4gICAgICAgIHRhZ3M6IFsncmViYWxhbmNpbmcnLCAndHJhZGUnXSxcclxuICAgICAgICBhdXRob3I6IGhvdXNlaG9sZC5hZHZpc29yTmFtZSxcclxuICAgICAgfVxyXG4gICAgXSxcclxuICAgIHRvdGFsQ291bnQ6IDIsXHJcbiAgICBoYXNNb3JlOiBmYWxzZSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUNhc2hUcmVuZERhdGEoaG91c2Vob2xkSWQ6IHN0cmluZywgcmFuZ2U6IHN0cmluZywgdG90YWxDYXNoOiBudW1iZXIpIHtcclxuICBjb25zdCB2YWxpZFJhbmdlcyA9IFsnM00nLCAnNk0nLCAnMVknXSBhcyBjb25zdDtcclxuICBjb25zdCB2YWxpZFJhbmdlID0gdmFsaWRSYW5nZXMuaW5jbHVkZXMocmFuZ2UgYXMgYW55KSA/IHJhbmdlIGFzIGFueSA6ICc2TSc7XHJcbiAgXHJcbiAgY29uc3QgcmFuZ2VDb25maWc6IFJlY29yZDx0eXBlb2YgdmFsaWRSYW5nZSwgeyBkYXlzOiBudW1iZXI7IHBvaW50czogbnVtYmVyIH0+ID0ge1xyXG4gICAgJzNNJzogeyBkYXlzOiA5MCwgcG9pbnRzOiAyMCB9LFxyXG4gICAgJzZNJzogeyBkYXlzOiAxODAsIHBvaW50czogMzAgfSxcclxuICAgICcxWSc6IHsgZGF5czogMzY1LCBwb2ludHM6IDUwIH0sXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY29uZmlnID0gcmFuZ2VDb25maWdbdmFsaWRSYW5nZV07XHJcbiAgY29uc3QgZGF0YSA9IFtdO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLnBvaW50czsgaSsrKSB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChjb25maWcuZGF5cyAtIChpICogY29uZmlnLmRheXMgLyBjb25maWcucG9pbnRzKSkpO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBncmFkdWFsIHRyZW5kIHdpdGggc29tZSB2YXJpYXRpb25cclxuICAgIGNvbnN0IHByb2dyZXNzID0gaSAvIGNvbmZpZy5wb2ludHM7XHJcbiAgICBjb25zdCBzZWVkID0gKGhvdXNlaG9sZElkLmNoYXJDb2RlQXQoMCkgKyBpKSAlIDEwMDtcclxuICAgIGNvbnN0IHZhcmlhdGlvbiA9IChzZWVkIC0gNTApIC8gNTAwOyAvLyBTbWFsbCB2YXJpYXRpb25zXHJcbiAgICBcclxuICAgIGNvbnN0IGJhbGFuY2UgPSB0b3RhbENhc2ggKiAoMC45ICsgMC4xICogcHJvZ3Jlc3MgKyB2YXJpYXRpb24pO1xyXG4gICAgXHJcbiAgICBkYXRhLnB1c2goe1xyXG4gICAgICBkYXRlOiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgYmFsYW5jZTogTWF0aC5tYXgoMCwgYmFsYW5jZSksXHJcbiAgICAgIGNoZWNraW5nOiBNYXRoLm1heCgwLCBiYWxhbmNlICogMC40KSxcclxuICAgICAgc2F2aW5nczogTWF0aC5tYXgoMCwgYmFsYW5jZSAqIDAuNiksXHJcbiAgICAgIGNkOiAwLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9ja0Nhc2goaG91c2Vob2xkSWQ6IHN0cmluZywgcmFuZ2U6IHN0cmluZyA9ICc2TScpOiBDYXNoUmVzcG9uc2Uge1xyXG4gIGNvbnN0IGhvdXNlaG9sZCA9IGdldEhvdXNlaG9sZEJ5SWQoaG91c2Vob2xkSWQpO1xyXG4gIGlmICghaG91c2Vob2xkKSB0aHJvdyBuZXcgRXJyb3IoJ0hvdXNlaG9sZCBub3QgZm91bmQnKTtcclxuXHJcbiAgY29uc3QgY2hlY2tpbmdCYWxhbmNlID0gaG91c2Vob2xkLnRvdGFsQ2FzaCAqIDAuNDtcclxuICBjb25zdCBzYXZpbmdzQmFsYW5jZSA9IGhvdXNlaG9sZC50b3RhbENhc2ggKiAwLjY7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhY2NvdW50czogW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IGAke2hvdXNlaG9sZElkfS1jaGVja2luZ2AsXHJcbiAgICAgICAgbmFtZTogYCR7aG91c2Vob2xkLm5hbWV9IENoZWNraW5nYCxcclxuICAgICAgICB0eXBlOiAnY2hlY2tpbmcnIGFzIGNvbnN0LFxyXG4gICAgICAgIGJhbGFuY2U6IGNoZWNraW5nQmFsYW5jZSxcclxuICAgICAgICBhcHk6IDAuMSxcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBpbnN0aXR1dGlvbjogJ0NoYXNlIEJhbmsnLFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IGAke2hvdXNlaG9sZElkfS1zYXZpbmdzYCxcclxuICAgICAgICBuYW1lOiBgJHtob3VzZWhvbGQubmFtZX0gSGlnaCBZaWVsZCBTYXZpbmdzYCxcclxuICAgICAgICB0eXBlOiAnc2F2aW5ncycgYXMgY29uc3QsXHJcbiAgICAgICAgYmFsYW5jZTogc2F2aW5nc0JhbGFuY2UsXHJcbiAgICAgICAgYXB5OiA0LjUsXHJcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgICAgaW5zdGl0dXRpb246ICdNYXJjdXMgYnkgR29sZG1hbiBTYWNocycsXHJcbiAgICAgIH1cclxuICAgIF0sXHJcbiAgICB0b3RhbEJhbGFuY2U6IGhvdXNlaG9sZC50b3RhbENhc2gsXHJcbiAgICBhdmdZaWVsZDogMi44LFxyXG4gICAgdHJlbmREYXRhOiBnZW5lcmF0ZUNhc2hUcmVuZERhdGEoaG91c2Vob2xkSWQsIHJhbmdlLCBob3VzZWhvbGQudG90YWxDYXNoKSxcclxuICAgIGFsZXJ0czogW10sXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vY2tQbGFubmluZyhob3VzZWhvbGRJZDogc3RyaW5nKTogUGxhbm5pbmdSZXNwb25zZSB7XHJcbiAgY29uc3QgaG91c2Vob2xkID0gZ2V0SG91c2Vob2xkQnlJZChob3VzZWhvbGRJZCk7XHJcbiAgaWYgKCFob3VzZWhvbGQpIHRocm93IG5ldyBFcnJvcignSG91c2Vob2xkIG5vdCBmb3VuZCcpO1xyXG5cclxuICBjb25zdCBpc1JldGlyZW1lbnRBZ2UgPSBob3VzZWhvbGQubmFtZS5pbmNsdWRlcygnUmV0aXJlbWVudCcpIHx8IGhvdXNlaG9sZC5yaXNrUHJvZmlsZSA9PT0gJ0NvbnNlcnZhdGl2ZSc7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBybWRzOiBpc1JldGlyZW1lbnRBZ2UgPyBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogYCR7aG91c2Vob2xkSWR9LXJtZC0xYCxcclxuICAgICAgICBhY2NvdW50TmFtZTogJ1RyYWRpdGlvbmFsIElSQScsXHJcbiAgICAgICAgb3duZXI6IGhvdXNlaG9sZC5wcmltYXJ5Q29udGFjdCxcclxuICAgICAgICBkdWVEYXRlOiAnMjAyNS0xMi0zMVQyMzo1OTo1OVonLFxyXG4gICAgICAgIHJlcXVpcmVkQW1vdW50OiBob3VzZWhvbGQudG90YWxBc3NldHMgKiAwLjA0LFxyXG4gICAgICAgIGNvbXBsZXRlZEFtb3VudDogMCxcclxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcclxuICAgICAgfVxyXG4gICAgXSA6IFtdLFxyXG4gICAgYmVuZWZpY2lhcmllczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IGAke2hvdXNlaG9sZElkfS1iZW4tMWAsXHJcbiAgICAgICAgYWNjb3VudE5hbWU6ICdQcmltYXJ5IEludmVzdG1lbnQgQWNjb3VudCcsXHJcbiAgICAgICAgYWNjb3VudFR5cGU6ICdJbnZlc3RtZW50JyxcclxuICAgICAgICBoYXNQcmltYXJ5OiB0cnVlLFxyXG4gICAgICAgIGhhc0NvbnRpbmdlbnQ6IHRydWUsXHJcbiAgICAgICAgbGFzdFJldmlld2VkOiAnMjAyNS0wMS0xNVQwMDowMDowMFonLFxyXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlJyBhcyBjb25zdCxcclxuICAgICAgfVxyXG4gICAgXSxcclxuICAgIG5leHRJbnRlcmFjdGlvbjoge1xyXG4gICAgICBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB0eXBlOiAncmV2aWV3JyxcclxuICAgICAgZGVzY3JpcHRpb246ICdRdWFydGVybHkgcG9ydGZvbGlvIHJldmlldyBhbmQgcGxhbm5pbmcgZGlzY3Vzc2lvbicsXHJcbiAgICB9LFxyXG4gICAgY3VzdG9kaWFsVHJhbnNpdGlvbnM6IFtdLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2NrUG9zaXRpb25zKGhvdXNlaG9sZElkOiBzdHJpbmcpOiBQb3NpdGlvbnNSZXNwb25zZSB7XHJcbiAgY29uc3QgaG91c2Vob2xkID0gZ2V0SG91c2Vob2xkQnlJZChob3VzZWhvbGRJZCk7XHJcbiAgaWYgKCFob3VzZWhvbGQpIHRocm93IG5ldyBFcnJvcignSG91c2Vob2xkIG5vdCBmb3VuZCcpO1xyXG5cclxuICBjb25zdCBpbnZlc3RlZEFzc2V0cyA9IGhvdXNlaG9sZC50b3RhbEFzc2V0cyAtIGhvdXNlaG9sZC50b3RhbENhc2g7XHJcbiAgY29uc3QgcG9zaXRpb25zID0gW1xyXG4gICAge1xyXG4gICAgICBpZDogYCR7aG91c2Vob2xkSWR9LXBvcy0xYCxcclxuICAgICAgc3ltYm9sOiAnQUFQTCcsXHJcbiAgICAgIG5hbWU6ICdBcHBsZSBJbmMuJyxcclxuICAgICAgYXNzZXRDbGFzczogJ0VxdWl0eScgYXMgY29uc3QsXHJcbiAgICAgIHF1YW50aXR5OiBNYXRoLmZsb29yKGludmVzdGVkQXNzZXRzICogMC4xNSAvIDE3NSksXHJcbiAgICAgIG1hcmtldFZhbHVlOiBpbnZlc3RlZEFzc2V0cyAqIDAuMTUsXHJcbiAgICAgIGNvc3RCYXNpczogaW52ZXN0ZWRBc3NldHMgKiAwLjE1ICogMC45LFxyXG4gICAgICB3ZWlnaHQ6IDE1LjAsXHJcbiAgICAgIGxhc3RQcmljZTogMTc1LjI1LFxyXG4gICAgICBzZWN0b3I6ICdUZWNobm9sb2d5JyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGlkOiBgJHtob3VzZWhvbGRJZH0tcG9zLTJgLFxyXG4gICAgICBzeW1ib2w6ICdWVEknLFxyXG4gICAgICBuYW1lOiAnVmFuZ3VhcmQgVG90YWwgU3RvY2sgTWFya2V0IEVURicsXHJcbiAgICAgIGFzc2V0Q2xhc3M6ICdFcXVpdHknIGFzIGNvbnN0LFxyXG4gICAgICBxdWFudGl0eTogTWF0aC5mbG9vcihpbnZlc3RlZEFzc2V0cyAqIDAuMzUgLyAyNDApLFxyXG4gICAgICBtYXJrZXRWYWx1ZTogaW52ZXN0ZWRBc3NldHMgKiAwLjM1LFxyXG4gICAgICBjb3N0QmFzaXM6IGludmVzdGVkQXNzZXRzICogMC4zNSAqIDAuOTUsXHJcbiAgICAgIHdlaWdodDogMzUuMCxcclxuICAgICAgbGFzdFByaWNlOiAyNDAuMTUsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBpZDogYCR7aG91c2Vob2xkSWR9LXBvcy0zYCxcclxuICAgICAgc3ltYm9sOiAnQk5EJyxcclxuICAgICAgbmFtZTogJ1Zhbmd1YXJkIFRvdGFsIEJvbmQgTWFya2V0IEVURicsXHJcbiAgICAgIGFzc2V0Q2xhc3M6ICdGaXhlZCBJbmNvbWUnIGFzIGNvbnN0LFxyXG4gICAgICBxdWFudGl0eTogTWF0aC5mbG9vcihpbnZlc3RlZEFzc2V0cyAqIDAuMjUgLyA3OCksXHJcbiAgICAgIG1hcmtldFZhbHVlOiBpbnZlc3RlZEFzc2V0cyAqIDAuMjUsXHJcbiAgICAgIGNvc3RCYXNpczogaW52ZXN0ZWRBc3NldHMgKiAwLjI1ICogMS4wMixcclxuICAgICAgd2VpZ2h0OiAyNS4wLFxyXG4gICAgICBsYXN0UHJpY2U6IDc4LjQ1LFxyXG4gICAgfVxyXG4gIF07XHJcblxyXG4gIGNvbnN0IHRvdGFsTWFya2V0VmFsdWUgPSBwb3NpdGlvbnMucmVkdWNlKChzdW0sIHBvcykgPT4gc3VtICsgcG9zLm1hcmtldFZhbHVlLCAwKTtcclxuICBjb25zdCB0b3RhbENvc3RCYXNpcyA9IHBvc2l0aW9ucy5yZWR1Y2UoKHN1bSwgcG9zKSA9PiBzdW0gKyBwb3MuY29zdEJhc2lzLCAwKTtcclxuICBjb25zdCB0b3RhbEdhaW5Mb3NzID0gdG90YWxNYXJrZXRWYWx1ZSAtIHRvdGFsQ29zdEJhc2lzO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcG9zaXRpb25zLFxyXG4gICAgc3VtbWFyeToge1xyXG4gICAgICB0b3RhbE1hcmtldFZhbHVlLFxyXG4gICAgICB0b3RhbENvc3RCYXNpcyxcclxuICAgICAgdG90YWxHYWluTG9zcyxcclxuICAgICAgdG90YWxHYWluTG9zc1BlcmNlbnQ6ICh0b3RhbEdhaW5Mb3NzIC8gdG90YWxDb3N0QmFzaXMpICogMTAwLFxyXG4gICAgICBwb3NpdGlvbnNDb3VudDogcG9zaXRpb25zLmxlbmd0aCxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vY2tSZXBvcnRzKGhvdXNlaG9sZElkOiBzdHJpbmcpOiBSZXBvcnRzUmVzcG9uc2Uge1xyXG4gIGNvbnN0IGhvdXNlaG9sZCA9IGdldEhvdXNlaG9sZEJ5SWQoaG91c2Vob2xkSWQpO1xyXG4gIGlmICghaG91c2Vob2xkKSB0aHJvdyBuZXcgRXJyb3IoJ0hvdXNlaG9sZCBub3QgZm91bmQnKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRlbWVudHM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBgJHtob3VzZWhvbGRJZH0tc3RtdC1tb250aGx5YCxcclxuICAgICAgICBuYW1lOiBgTW9udGhseSBTdGF0ZW1lbnQgLSAke2hvdXNlaG9sZC5uYW1lfWAsXHJcbiAgICAgICAgdHlwZTogJ21vbnRobHknIGFzIGNvbnN0LFxyXG4gICAgICAgIGRhdGU6ICcyMDI1LTA5LTAxVDAwOjAwOjAwWicsXHJcbiAgICAgICAgc2l6ZTogJzIuMyBNQicsXHJcbiAgICAgICAgdXJsOiBgL3N0YXRlbWVudHMvJHtob3VzZWhvbGRJZH0vbW9udGhseS0yMDI1LTA5LnBkZmAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogYCR7aG91c2Vob2xkSWR9LXN0bXQtcXVhcnRlcmx5YCxcclxuICAgICAgICBuYW1lOiBgUXVhcnRlcmx5IFBlcmZvcm1hbmNlIFJlcG9ydCAtICR7aG91c2Vob2xkLm5hbWV9YCxcclxuICAgICAgICB0eXBlOiAncXVhcnRlcmx5JyBhcyBjb25zdCxcclxuICAgICAgICBkYXRlOiAnMjAyNS0wNy0wMVQwMDowMDowMFonLFxyXG4gICAgICAgIHNpemU6ICcxLjggTUInLFxyXG4gICAgICAgIHVybDogYC9zdGF0ZW1lbnRzLyR7aG91c2Vob2xkSWR9L3F1YXJ0ZXJseS0yMDI1LXEzLnBkZmAsXHJcbiAgICAgIH1cclxuICAgIF0sXHJcbiAgICBhbmFseXRpY3M6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBgJHtob3VzZWhvbGRJZH0tYW5hbHl0aWNzLXBlcmZvcm1hbmNlYCxcclxuICAgICAgICBuYW1lOiAnUG9ydGZvbGlvIFBlcmZvcm1hbmNlIEFuYWx5c2lzJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYENvbXByZWhlbnNpdmUgcGVyZm9ybWFuY2UgYW5hbHlzaXMgZm9yICR7aG91c2Vob2xkLm5hbWV9IGluY2x1ZGluZyByaXNrIG1ldHJpY3MgYW5kIGF0dHJpYnV0aW9uYCxcclxuICAgICAgICBnZW5lcmF0ZWREYXRlOiAnMjAyNS0wOS0yNFQwMDowMDowMFonLFxyXG4gICAgICAgIHVybDogYC9hbmFseXRpY3MvJHtob3VzZWhvbGRJZH0vcGVyZm9ybWFuY2UtYW5hbHlzaXMucGRmYCxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBgJHtob3VzZWhvbGRJZH0tYW5hbHl0aWNzLWFsbG9jYXRpb25gLFxyXG4gICAgICAgIG5hbWU6ICdBc3NldCBBbGxvY2F0aW9uIFJldmlldycsXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdDdXJyZW50IHZzIHRhcmdldCBhbGxvY2F0aW9uIHdpdGggcmViYWxhbmNpbmcgcmVjb21tZW5kYXRpb25zJyxcclxuICAgICAgICBnZW5lcmF0ZWREYXRlOiAnMjAyNS0wOS0yMFQwMDowMDowMFonLFxyXG4gICAgICAgIHVybDogYC9hbmFseXRpY3MvJHtob3VzZWhvbGRJZH0vYWxsb2NhdGlvbi1yZXZpZXcucGRmYCxcclxuICAgICAgfVxyXG4gICAgXSxcclxuICB9O1xyXG59Il0sIm5hbWVzIjpbImdldEhvdXNlaG9sZEJ5SWQiLCJnZXRNb2NrT3ZlcnZpZXciLCJob3VzZWhvbGRJZCIsImhvdXNlaG9sZCIsIkVycm9yIiwiaWQiLCJuYW1lIiwicHJpbWFyeUFkdmlzb3IiLCJhZHZpc29yTmFtZSIsInJpc2tQcm9maWxlIiwibGFzdFN5bmMiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0b3RhbEFzc2V0cyIsInl0ZFJldHVybiIsInl0ZFBlcmZvcm1hbmNlIiwiYmVuY2htYXJrUmV0dXJuIiwiYWNjb3VudHNDb3VudCIsInRvdGFsQ2FzaCIsImF2Z0Nhc2hZaWVsZCIsImV4ZWN1dGl2ZVN1bW1hcnkiLCJ0b0ZpeGVkIiwidG9Mb3dlckNhc2UiLCJsYXN0VXBkYXRlZCIsImdldE1vY2tQZXJmb3JtYW5jZSIsInJhbmdlIiwidmFsaWRSYW5nZXMiLCJ2YWxpZFJhbmdlIiwiaW5jbHVkZXMiLCJyYW5nZUNvbmZpZyIsImRheXMiLCJwb2ludHMiLCJjb25maWciLCJkYXRhIiwiYmFzZVZhbHVlIiwiYmFzZVJldHVybiIsImkiLCJkYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJwcm9ncmVzcyIsInBlcmZvcm1hbmNlTXVsdGlwbGllciIsInZvbGF0aWxpdHlGYWN0b3IiLCJzZWVkIiwiY2hhckNvZGVBdCIsInZvbGF0aWxpdHkiLCJNYXRoIiwic2luIiwidHJlbmRSZXR1cm4iLCJmaW5hbFZhbHVlIiwiYmVuY2htYXJrVmFsdWUiLCJwdXNoIiwic3BsaXQiLCJ2YWx1ZSIsInJvdW5kIiwiYmVuY2htYXJrIiwidG90YWxSZXR1cm4iLCJzaGFycGVSYXRpbyIsImdldE1vY2tBbGxvY2F0aW9uIiwiYWxsb2NhdGlvbiIsInBlcmNlbnRhZ2UiLCJjb2xvciIsInBvbGljeURyaWZ0IiwicmViYWxhbmNlTmVlZGVkIiwibGFzdFJlYmFsYW5jZSIsImdldE1vY2tBY3Rpdml0eSIsImFjdGl2aXRpZXMiLCJ0eXBlIiwicHJpb3JpdHkiLCJzdGF0dXMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidGFncyIsImF1dGhvciIsIm5vdyIsInRvdGFsQ291bnQiLCJoYXNNb3JlIiwiZ2VuZXJhdGVDYXNoVHJlbmREYXRhIiwidmFyaWF0aW9uIiwiYmFsYW5jZSIsIm1heCIsImNoZWNraW5nIiwic2F2aW5ncyIsImNkIiwiZ2V0TW9ja0Nhc2giLCJjaGVja2luZ0JhbGFuY2UiLCJzYXZpbmdzQmFsYW5jZSIsImFjY291bnRzIiwiYXB5IiwiaXNBY3RpdmUiLCJpbnN0aXR1dGlvbiIsInRvdGFsQmFsYW5jZSIsImF2Z1lpZWxkIiwidHJlbmREYXRhIiwiYWxlcnRzIiwiZ2V0TW9ja1BsYW5uaW5nIiwiaXNSZXRpcmVtZW50QWdlIiwicm1kcyIsImFjY291bnROYW1lIiwib3duZXIiLCJwcmltYXJ5Q29udGFjdCIsImR1ZURhdGUiLCJyZXF1aXJlZEFtb3VudCIsImNvbXBsZXRlZEFtb3VudCIsImJlbmVmaWNpYXJpZXMiLCJhY2NvdW50VHlwZSIsImhhc1ByaW1hcnkiLCJoYXNDb250aW5nZW50IiwibGFzdFJldmlld2VkIiwibmV4dEludGVyYWN0aW9uIiwiY3VzdG9kaWFsVHJhbnNpdGlvbnMiLCJnZXRNb2NrUG9zaXRpb25zIiwiaW52ZXN0ZWRBc3NldHMiLCJwb3NpdGlvbnMiLCJzeW1ib2wiLCJhc3NldENsYXNzIiwicXVhbnRpdHkiLCJmbG9vciIsIm1hcmtldFZhbHVlIiwiY29zdEJhc2lzIiwid2VpZ2h0IiwibGFzdFByaWNlIiwic2VjdG9yIiwidG90YWxNYXJrZXRWYWx1ZSIsInJlZHVjZSIsInN1bSIsInBvcyIsInRvdGFsQ29zdEJhc2lzIiwidG90YWxHYWluTG9zcyIsInN1bW1hcnkiLCJ0b3RhbEdhaW5Mb3NzUGVyY2VudCIsInBvc2l0aW9uc0NvdW50IiwibGVuZ3RoIiwiZ2V0TW9ja1JlcG9ydHMiLCJzdGF0ZW1lbnRzIiwic2l6ZSIsInVybCIsImFuYWx5dGljcyIsImdlbmVyYXRlZERhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mock-api-data.ts\n"));

/***/ })

});